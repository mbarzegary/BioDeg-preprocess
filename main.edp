load "msh3"
load "medit"
load "distance"
load "iovtk"
load "parmmg"
load "mshmet"
load "tetgen"

string meshFileName = "demo/gyroid-scaffold.mesh";
string solFileName = meshFileName + ".sol";
string outputFileName = meshFileName + "-out.mesh";

real sizeX = 16 + 10;
real sizeY = 16 + 10;
real sizeZ = 25 + 10;
real centerX = sizeX/2;
real centerY = sizeY/2;
real centerZ = sizeZ/2;
int meshSize = 60; // number of mesh nodes on each edge of the box

bool writeTestVtk = true;

bool refineMesh = true;
string vtkFileName = meshFileName + ".vtu";
real wd = 0.1; // threshold of phi for determining the refined region
real mshmetError = 0.008; // tolerance for mesh refinement, used by mshmet
real meshMin = 0.1; // minimum size of elements during mesh refinement
real meshMax = 3; // minimum size of elements during mesh refinement
real hausd = 1.0;
real hgrad = 1.3;
int nIterations = 3;
int allowedMemory = 30000;

mesh3 Mesh;
mesh3 MeshScaffold;

if (mpirank == 0)
{
  cout << "Generating mesh..." << endl;
  Mesh = cube(2, 2, 2, [sizeX*x-centerX, sizeY*y-centerY, sizeZ*z-centerZ]);
  real[int] domain = [0, 0, 0, 0, 1];
  Mesh = tetgreconstruction(Mesh, switch="raAQ", regionlist=domain,
                          sizeofvolume=(sizeX/meshSize)*(sizeY/meshSize)*(sizeZ/meshSize)/6);
}
MeshScaffold = readmesh3(meshFileName);
broadcast(processor(0), Mesh);

fespace SpaceP1(Mesh, P1);
SpaceP1 phi = 0;

SpaceP1 X = x;
SpaceP1 Y = y;
SpaceP1 Z = z;

if (mpirank == 0)
{
  cout << "Processing nodes..." << endl;
  for (int i = 0; i < SpaceP1.ndof; i++)
  {
    if (chi(MeshScaffold)(X[][i], Y[][i], Z[][i]) == 1)
      phi[][i] = 1;
    cout << "\rProcessed: " << i << " / " << SpaceP1.ndof;
  }
  cout << endl;
}
broadcast(processor(0), phi[]);

phi = phi - 0.5;

if (refineMesh)
{
  if (mpirank == 0)
    cout << "Refining the mesh..." << endl;

  SpaceP1 phiTemp;
  distance(Mesh, phi, phiTemp[]);
  phi = phiTemp;

  Mesh = change(Mesh, flabel=0);
  Mesh = change(Mesh, fregion=0);

  SpaceP1 sol = 0.5 * (phi > wd) + -0.5 * (phi < -wd) + 0 * (phi >= -wd) * (phi <= wd);

  SpaceP1 met;
  met[] = mshmet(Mesh, sol, aniso=0, hmin=meshMin, hmax=meshMax, err=mshmetError);
  Mesh = parmmg3d(Mesh, metric=met[], hausd=hausd, hgrad=hgrad, verbose=10,
                  niter=nIterations, mem=allowedMemory, comm=mpiCommWorld);
  phi = phi;
}

if (writeTestVtk)
{
  if (mpirank == 0)
  {
    int[int] orderOut = [1];
    savevtk(vtkFileName, Mesh, phi, dataname="phi", order=orderOut);
  }
}

if (mpirank == 0)
{
  savesol(solFileName, Mesh, phi);
  savemesh(Mesh, outputFileName);

  cout << "Finite Element DOF: " + SpaceP1.ndof << endl;
  cout << "Number of Elements: " + Mesh.nt << endl;;
}
